<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // Set中没有重复的值
        let set = new Set([1, 1, 2, 2, 3, 3])
        console.log(set);           // 里面包含了各个item和一个size属性



        /* 
        Set 结构的实例有以下属性。
        Set.prototype.constructor：构造函数，默认就是Set函数。
        Set.prototype.size：        返回Set实例的成员总数。

        Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。
        下面先介绍四个操作方法。
        Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
        Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
        Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
        Set.prototype.clear()：清除所有成员，没有返回值。
        */

        let colorSet = new Set(['red', 'green', 'blue']);
        console.log(colorSet);

        // Set数据类型的键值是一样的
        for (let item of colorSet.keys()) {
            console.log(item);
        }
        // red
        // green
        // blue

        for (let item of colorSet.values()) {
            console.log(item);
        }
        // red
        // green
        // blue

        for (let item of colorSet.entries()) {
            console.log(item);
        }
        // ["red", "red"]
        // ["green", "green"]
        // ["blue", "blue"]






        // ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
        // Map()传入的参数一定要是一个可迭代对象
        let map = new Map([['a', 1], ['b', 2]])
        let map1 = new Map(new Set([['c', 3], ['d', 4]]))
        console.log(map, map1);

        // 添加一个Map，任何数据类型都可以作为Map的key
        map.set(1, '1')
        map.set(Symbol(), 'hello')
        map.set({ key: true }, 'value')
        map.set(false, 'false')
        console.log(map);

        console.log(map.has(false));        // true
        console.log(map.has(Symbol()));     // false，注意这里是false，因为symbol很特殊，其值是唯一的，即使两个symbol声明方式一样，他们也是两个不同的数据

        console.log(map.get(1));            // 1
        console.log(map.get(Symbol()));     // undefined 原因和上面相同

        // 遍历方法
        const newMap = new Map([
            ['F', 'no'],
            ['T', 'yes'],
        ]);

        for (let key of newMap.keys()) {
            console.log(key);
        }
        // "F"
        // "T"

        for (let value of newMap.values()) {
            console.log(value);
        }
        // "no"
        // "yes"

        for (let item of newMap.entries()) {
            console.log(item[0], item[1]);
        }
        // "F" "no"
        // "T" "yes"

        // 或者
        for (let [key, value] of newMap.entries()) {
            console.log(key, value);
        }
        // "F" "no"
        // "T" "yes"

        // 等同于使用map.entries()
        for (let [key, value] of newMap) {
            console.log(key, value);
        }
        // "F" "no"
        // "T" "yes"

        // WeakSet 和 WeakMap
        // WeakSet 只能存放对象，且该对象是弱引用的，一旦改对象的引用消失，该对象就会被GC回收
        // 比如：
        let someObj = { a: { prop: 'weakProp' } }
        let weakSet = new WeakSet([someObj.a])
        // delete someObj  // 删掉someObj，此时GC会自动回收


        // WeakMap 只能用对象做为键，同

    </script>
</body>

</html>