<html>
<head>
  <title>4.DBWn,CKPT,LGWR进程</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="486"/>
<h1>4.DBWn,CKPT,LGWR进程</h1>

<div>
<span><div><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">4.DBWn,CKPT,LGWR</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">进程</span></div><div><br/></div><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">   </span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">首先，简要介绍一下：</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">      DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">：</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: #000066; font-weight: bold; font-family: 宋体;">数据库</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">块写入器（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Database Block Writer</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">）负责将脏块写入磁盘的后台进程。</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">      CKPT</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">：检查点进程（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Checkpoint Process</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">）只是更新数据文件的文件首部，以辅助建立检查点的进程（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">）。</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">      LGWR</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">：日志写入器（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Log Writer</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">）负责将</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">SGA</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">中重做日志缓冲区的内容刷新输出到磁盘。</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">     </span></div><div style="margin: 7.5pt 0cm; line-height: 15.75pt; word-break: break-all;"><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">其实这三个进程都是为了更好地完成一件事：安全高效地实现内存数据块写入数据文件，就是将内存中修改的数据反映到硬盘的数据文件上。</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div style="margin: 7.5pt 0cm; line-height: 15.75pt; word-break: break-all;"><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">将内存数据块写入数据文件实在是一个相当复杂的过程，在这个过程中，首先要保证安全。所谓安全，就是在写的过程中，一旦发生实例崩溃，要有一套完整的机制能够保证用户已经提交的数据不会丢失；其次，在保证安全的基础上，要尽可能地提高效率。众所周知，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">I/O</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">操作是最昂贵的操作，所以应该尽可能地将脏数据块收集到一定程度以后，再批量写入磁盘中。</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div style="margin: 7.5pt 0cm; line-height: 15.75pt; word-break: break-all;"><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">直观上最简单的解决方法就是，每当用户提交的时候就将所改变的内存数据块交给</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">，由其写入数据文件。这样的话，一定能够保证提交的数据不会丢失。但是这种方式效率最为低下，在高并发环境中，一定会引起</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">I/O</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">方面的争用。</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">当然不会采用这种没有伸缩性的方式。</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">引入了</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">CKPT</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">和</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">LGWR</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">这两个后台进程，这两个进程与</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">进程互相合作，提供了既安全又高效的写脏数据块的解决方法。</span></div><p style="margin-top: 7.5pt; margin-right: 0cm; margin-bottom: 7.5pt; margin-left: 0cm; line-height: 15.75pt; word-break: break-all;"></p><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">        </span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">第一：如何保证安全？</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;"> </span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">     </span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">用户进程每次修改内存数据块时，都会在日志缓冲区（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">log buffer</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">）中构造一个相应的重做条目（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">redo entry</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">），该重做条目描述了被修改的数据块在修改之前和修改之后的值。而</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">LGWR</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">进程则负责将这些重做条目写入联机日志文件。只要重做条目进入了联机日志文件，那么数据的安全就有保障了，否则这些数据都是有安全隐患的。</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">LGWR</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">是一个必须和前台用户进程通信的进程。</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">LGWR</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">承担了维护系统数据完整性的任务，它保证了数据在任何情况下都不会丢失。</span></div><div style="margin: 7.5pt 0cm; line-height: 15.75pt; word-break: break-all;"><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">      </span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">假如</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWR</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">在写脏数据块的过程中，突然发生实例崩溃时，该怎么办？我们已经知道，用户提交时，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">是不一定会把提交的数据块写入数据文件的。那么实例崩溃时，必然会有一些已经提交但是还没有被写入数据文件的内存数据块丢失了。当实例再次启动时，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">需要利用日志文件中记录的重做条目在</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer cache</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">中重新构造出被丢失的数据块，从而完成前滚和回滚的工作，并将丢失的数据块找回来。于是这里就存在一个问题，就是</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">在日志文件中找重做条目时，到底应该找哪些重做条目？换句话说，应该在日志文件中从哪个起点开始往后应用重做条目？注意，这里所指的日志文件可能不止一个日志文件。</span></div><div style="margin: 7.5pt 0cm; line-height: 15.75pt; word-break: break-all;"><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">这个起点意义重大，在日志文件中位于这个起点之前的重做条目所对应的在</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer cache</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">中的脏数据块已经被写入了数据文件，从而在实例崩溃以后的恢复中不需要去考虑。而这个起点以后的重做条目所对应的脏数据块实际还没有被写入数据文件，如果在实例崩溃以后的恢复中，需要从这个起点开始往后，依次取出日志文件中的重做条目进行恢复。考虑到目前的内存容量越来越大，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer cache</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">也越来越大，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer cache</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">中包含几百万个内存数据块也是很正常的现象的前提下，如何才能最有效的来定位这个起点呢？</span></div><div style="margin: 7.5pt 0cm; line-height: 15.75pt; word-break: break-all;"><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">为了能够确定这个最佳的起点，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">引入了名为</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">CKPT</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">的后台进程，通常也叫作检查点进程（</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">checkpoint process</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">）。这个进程与</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">共同合作，从而确定这个起点。同时，这个起点也有一个专门的名字，叫做检查点位置（</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">checkpoint position</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">，该检查点位置记录在控制文件里）。</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">为了在检查点的算法上更加的具有可扩展性（也就是为了能够在巨大的</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer cache</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">下依然有效工作），引入了检查点队列（</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">checkpoint queue</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">），该队列上串起来的都是脏数据块所对应的</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer header</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">。而每次</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">写脏数据块时，也是从检查点队列上扫描脏数据块，并将这些脏数据块实际写入数据文件的。当写完以后，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">会将这些已经写入数据文件的脏数据块从检查点队列上摘下来。这样即便是在巨大的</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer cache</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">下工作，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">CKPT</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">也能够快速的确定哪些脏数据块已经被写入了数据文件，而哪些还没有写入数据文件，显然，只要在检查点队列上的数据块都是还没有写入数据文件的脏数据块。同时为了能够尽量减少实例崩溃后恢复的时间，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">还引入了增量检查点（</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">incremental checkpoint</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">），从而增加了检查点启动的次数。如果每次检查点启动的间隔时间过长的话，再加上内存很大，可能会使得恢复的时间过长。因为前一次检查点启动以后，标识出了这个起点。然后在第二次检查点启动之前，</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">可能已经将很多脏数据块已经写入了数据文件，而假如在第二次检查点启动之前发生实例崩溃，导致在日志文件中，所标识的起点仍然是上一次检查点启动时所标识的，导致</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">不知道这个起点以后的很多重做条目所对应的脏数据块实际上已经写入了数据文件，从而使得</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Oracle</span><span style="line-height: 15.75pt; word-break: break-all; font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">在实例恢复时重复地处理一遍，效率低下，浪费时间。</span></div><p style="margin-top: 7.5pt; margin-right: 0cm; margin-bottom: 7.5pt; margin-left: 0cm; line-height: 15.75pt; word-break: break-all;"></p><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">上面说到了有关</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">CKPT</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">的两个重要的概念：检查点队列（包括文件队列）和增量检查点。检查点队列上的</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer header</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">是按照数据块第一次被修改的时间的先后顺序来排列的。越早修改的数据块的</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer header</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">排在越前面，同时如果一个数据块被修改了多次的话，在该链表上也只出现一次。而且，检查点队列上的</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">buffer header</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">还记录了脏数据块在第一次被修改时，所对应的重做条目在重做日志文件中的地址，也就是</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">LRBA</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">（</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Low Redo Block Address</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">），</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">Low</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">表示第一次修改时对应的</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">RBA</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">。每个检查点都会由</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">checkpoint queue latch</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">来保护。</span></div><div><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">     </span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">上面所描述的概念，用一句话来概括，其实就是</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">负责写检查点队列上的脏数据块，而</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">CKPT</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;">负责记录当前检查点队列的第一个数据块所对应的的重做条目在日志文件中的地址。而到底应该写哪些脏数据块，写多少脏数据块，则要到检查点队列上才能确定的。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: black;-en-paragraph:true;">     </span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">下面是我个人的理解：假设前台用户在某一分钟内正源源不断地进行更新数据。他每更新一个内存数据块，就会触发两个动作，其一，</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">LGWR</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">进程就会在日志缓冲区构造一个重做条目，保存一些修改的信息，便于今后在内存中重新构造出这块内存数据块。并把这个重做条目写入到重做日志文件。其二，</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">CKPT</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">进程负责将该内存块对应的</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">buffer header</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">加入检查点队列，</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">buffer header</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">相当于一个指针，通过它能够找到对应的内存块数据！那么</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">进程在干吗呢，它在收集修改过的内存数据块，假设收集到</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">50</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">块的时候，就将这</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">50</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">块修改过的内存数据反映到硬盘的数据文件里面。不过</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">只负责收集，修改硬盘数据交给了操作系统去处理，处理成功之后，操作系统给</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">一个信号，这个时候，</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">DBWn</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">就将这</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">50</span><span style="font-size: 13.5pt; mso-bidi-font-family: Arial; color: red;-en-paragraph:true;">块内存数据块对应的检查点从检查点队列上面摘下来！这样如果系统在写硬盘数据的时候突然崩溃，检查点队列里面对应的数据块都是修改了，但没来得及写入硬盘的！这样就保证了数据的安全与高效。不过这里我有一个疑问，增量检查点好像没用啊？我的理解肯定有点偏差。希望大家前来讨论！</span></div><div><span style="-en-paragraph:true;"> </span></div></div></span>
</div></body></html> 